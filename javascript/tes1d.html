
<head>
</head>
<html>
<body>
  <canvas style="background:black" id=drw width="1200" height="600"></canvas>
<script>

var micros=Date.now;
var c = document.getElementById("drw");
var ctx = c.getContext("2d");
zprintf=console.log;
function PSTR(x){return x;}
var float=parseFloat;
function fmax(a,b){return (a>=b)?a:b;}
function fmin(a,b){return (a>=b)?b:a;}
function InvSqrt(f) {return 1.0/Math.sqrt(f);}

function xInvSqrt(n) {return stepdiv2*(n>0.0625?InvSqrt(n):4);}
function zInvSqrt(n) {return stepdiv2/n;}
//function xInvSqrt(n) {return Math.round(Math.sqrt(n));}

var vv=[];
var ddd=[];
var CLOCKCONSTANT=1000000;
var STEPFREQ=50000;
var STEPCLOCK=Math.round(CLOCKCONSTANT/STEPFREQ);
var rampv=1;
var head=0;
var tail=0;
var NUMBUFFER=40;
var move=[];
var isG0;
var m;
var f=0;
var x1=0;
var y1=0;
var z1=0;
var e1=0;
var maxf=[100,100,100,100];
var stepmm=10;
var accel=50;
var jerk=200;
var zaccel=accel;
var mvaccel=accel;
var xycorner=5;
var zcorner=xycorner;
var labs=Math.abs;
var fabs=Math.abs;

var laxis;
var fastaxis;
var totalstep;
var oacup,acup;
var oacdn,acdn;
var ta;
var stepdiv,stepdiv2;
var nextmicros;
var rampup,rampdown;
var mctr2;
var nextdly;
var ldelay=0;

var dlp=0;
var cmd0=0;
var cmddelay=[0];
var cmdhead=0;
var cmdtail=0;
var lastmm=[0,0,0,0,0];
var currmm=[0,0,0,0,0];
var mmdis=[0,0,0,0,0];
var mcx=[0,0,0,0];
var bsdx=[0,0,0,0];
var sx=[0,0,0,0];

/// command buffer
var NUMCMDBUF=100000;
function nextbuffm(x) {return ((x) < NUMCMDBUF-1 ? (x) + 1 : 0);}
for (var i=0;i<NUMBUFFER;i++){move.push({});}
//for (var i=0;i<NUMCMDBUF;i++){cmddelay.push(0);}

var cmhead = 0;
var cmtail = 0;
var cmcmd;
var cmbit = 0;
var cmdlaserval = 0;

var mo = 0;
function cmdfull() {return nextbuffm(cmhead)==cmtail;}
function cmdnotfull() {return nextbuffm(cmhead)!=cmtail;}
function cmdempty () {return cmhead==cmtail;}

var nextok = 0;
var laserwason = 0;

var sendwait = 0;

var maincmdlaserval = 0;

function pushcmd()
{


  // if move cmd, and no motor move, save the delay
  if ( (cmd0 & 1) && !(cmd0 & (15 << 1))) {
    ldelay += cmd0 >> 5;
  } else {
    cmhead = nextbuffm(cmhead);
    if (cmd0 & 1)cmd0 += (ldelay << 5);
    //cmddelay[cmhead] = cmd0;
    cmddelay.push(cmd0);
	ddd.push(cmd0 >> 5);
    ldelay = 0;
  }

}

function newdircommand(laserval)
{
  // change dir command
  //cmd0 = 0;//DIRDELAY << 6;
  cmd0 = (laserval << 9);
  if (sx[0] > 0)cmd0 |= 2;
  if (sx[1] > 0)cmd0 |= 8;
  if (sx[2] > 0)cmd0 |= 32;
  if (sx[3] > 0)cmd0 |= 128;
  // TO know whether axis is moving
  if (bsdx[0] > 0)cmd0 |= 4;
  if (bsdx[1] > 0)cmd0 |= 16;
  if (bsdx[2] > 0)cmd0 |= 64;
  if (bsdx[3] > 0)cmd0 |= 256;
  ldelay = 0;
  pushcmd();

}



function bufflen() {return  head >= tail ? head - tail : (NUMBUFFER + head) - tail;} // 5+0 - 4

function nextbuff(x) {return (x) < NUMBUFFER-1 ? (x) + 1 : 0;}
function prevbuff(x) {return ((x) > 0 ? (x) - 1 : NUMBUFFER-1);}
function copy(a,b){
  for (var i=0;i<b.length;i++){
    a[i]=b[i];
  }
}

function int(x){return Math.floor(x);}
function max(a,b){return (a>=b)?a:b;}
function min(a,b){return (a<=b)?a:b;}
function abs(a){return Math.abs(a);}
var sqrt=Math.sqrt;
function sqr2(x){return x*x;}




var MINCORNERSPEED=1;
var lastf=0;
var curru=[0,0,0,0,0];
var prevu=[0,0,0,0,0];
var tailok=0;
var rampup=0;
var rampdown=0;


function FASTAXIS(m){
	return (m.status >> 4)&3;
}

function ramplenq(v0,v1,stepa) {
  if (v1>v0)return (v1-v0)*stepa;
  return 0;
}
function speedat(v0,a,s) {
    return (a * s  + v0);
}


var prevacc=0;
var nextacc=0;
var has1,has2,has3,has4,has5,has6,has7;
var s1,s2,s3,s4,s5,s6,s7;
var t1,t2,t3,t4,t5,t6,t7;
var tjerk,mvjerk,vjerk1,vjerk7;

function preparejerk(vi,vc,ve,j,a){
	// initial
	totalstep=Math.floor(mmdis*StepMM);
	workstep=0;	
	mmtomuch=0;
	mdis=0;
	loop=1;
	st1="";
	tjerk = a/j;
	mvjerk = 1/2*j*tjerk*tjerk;
	while (1){

		// time each segment
		// segment 1, constant jerk until v increase vjerk
		// a = a0+ J.T
		// T=a/J;

		// Vt = Vi + ai.T  + 1/2JT^2
		// Vt = Vi + 0 + 1/2JT^2   
		// T=sqrt(2(Vt-Vi)/J)

		//

		has1=0;
		vjerk1=mvjerk;
		if ((prevac<=0) && (vc>vi)){ // if previous is not accelerate up, and vinitial less than vcruise
			if ((vc-vi)<(2*vjerk1)){
				vjerk1=(vc-vi)/2; // cannot accelerate maximum
				t1=sqrt(2*vjerk1/j); // calc time to reac vjerk segment 1
			} else {
				t1=tjerk; // can use jerk to maximum acceleration value
			}
			vt1 = vi + vjerk1;
			s1 = vi*t1 + 1/6*j*t1*t1*t1;
			has1=1;
		} else { // doesnot have segment 1
			s1=0;
			vt1=vi;
			t1=0;
			vjerk1=0;
		}
		v1=vt1;

		// segment 2 constant acceleration until vcruise-vjerk
		// Vt = Vt1 + a.T
		// T = (Vt-Vt1)/a
		
		if (ve<=vc)vt2 = vc-mvjerk;else vt2 = vc-vjerk1;
		has2=0;
		if (vt2>vt1){
			t2 = (vt2-vt1)/a;
			s2 = vt1*t2 + 1/2*a*t2*t2;
			has2=1;
		} else {
			t2=0;
			s2=0;
			// if no room for acceleration and jerk, then we must change the segment1 later
		}
		v2=vt2;

		// segment 3 decelerate is same as segment 1
		has3=0;
		if ((ve<=vc) && (vi<vc)) { //we have cruise followed by deceleration 
			// check if dV is enough for jerk deceleration
			//if (vc-ve)>
			t3  = t1?t1:tjerk;
			s3 = vc*t3 - 1/6*j*t3*t3*t3;
			has3=1;
		} else {
			s3=0;
			t3=0;
		}
		v3=vc;

		// ===========================================================================================
		// segment 5,6,7 is calculated inversed from ve to vc just like segment 1,2,3
		// segment 7, constant jerk until v increase vjerk

		has7=0;
		vjerk7=mvjerk;
		v7=ve;
		if ((nextac>=0) && (vc>ve)){ // if previous is not accelerate up, and vinitial less than vcruise
			if ((vc-ve)<(2*vjerk7)){
				vjerk7=(vc-ve)/2; // cannot accelerate maximum
				t7=sqrt(2*vjerk7/j); // calc time to reac vjerk segment 1
			} else {
				t7=tjerk; // can use jerk to maximum acceleration value
			}
			vt7 = ve + vjerk7;
			s7 = ve*t7 + 1/6*j*t7*t7*t7;
			has7=1;
		} else { // doesnot have segment 1
			s7=0;
			vt7=ve;
			t7=0;
			vjerk7=0;
		}
		// segment 6 constant acceleration until vcruise-vjerk
		// Vt = Vt1 + a.T
		// T = (Vt-Vt1)/a

		has6=0;
		v6=vt7;

		if (nextac<0)vt6 = vc-mvjerk;else vt6 = vc-vjerk7;


		if (vt6>vt7){
			t6 = (vt6-vt7)/a;
			s6 = vt7*t6 + 1/2*a*t6*t6;
			has6=1;
		} else {
			t6=0;
			s6=0;
			// if no room for acceleration and jerk, then we must change the segment1 later
		}

		// segment 5 decelerate is same as segment 7
		has5=0;
		if (nextac<0)v5=vc-mvjerk;else v5=vc-vjerk7;
		
		if (ve<vc) { //if we have initial acceleration 
			t5  = t7?t7:tjerk;
			s5 = vc*t5 - 1/6*j*t5*t5*t5;
			has5=1;
		} else {
			s5=0;
			t5=0;
		}


		// cruise must be calculate last, we must know how much distance from jerk ramp up and jerk ramp down
		// segment 4  = cruise
		taccelerate = t1+t2+t3+t5+t6+t7;
		saccelerate = s1+s2+s3+s5+s6+s7;
		has4=0;
		v4=vc;
		if (mmdis>saccelerate){ // we have cruise
			has4=1;
			s4=mmdis-saccelerate;
			t4=s4/vc;
		} else {
			s4=mmdis-saccelerate;
			t4=0;
		}
		if (s4>=0)break;
		if (vc==vi+mvjerk)break;
		mmtomuch=s4;
		// adjust vcruise to meet the formula
		vc=fmax(vc*0.8,vi);
		vc=fmax(vc,vi<vc?vi+mvjerk:0);
		loop++;
		if (loop>15)break;
	}
	if (!has4)s4=0;
	T=taccelerate+t4;
	S=saccelerate+s4;

	 
// =======================================================================================	
// Optimized step generator using as minimum loop possible
// =======================================================================================
	
	// draw the graph
	// Segment1, constant jerk need most calculation
	a2=0;
	S=0;
	LS=0;
	tstep=0.1/StepMM;
	S0=0;
	V=vi;
	a1=a;
	if (has1){
		t=0;
		// this 0.5 need to adjusted depends on real mm step per machine step
		// for debugging
		Vi=vi+0.05; // just to prevent division by zero
		while (t<=t1){
		    // main code
			a1=j*t; // keep for next segment , or known from planner pass
			at=0.5*a1*t;			
			V=Vi+at;
			S=(Vi+0.3333*at)*t;
			if (S>s1)break;
			machinemove(1,S,V); // division in on machine move when determine inverse square
			t+=tstep;
		}
	}	
	S0=s1;
	/* segment 2 is simple constant acceleration
	
	Vf^2 = Vi^2 + 2aS
	so each step we only need to add 2a
	*/
	
	if (has2){

	// this 0.5 need to adjusted depends on real mm step per machine step
		as=2*a/StepMM;
		V2=sqr(V); // just to prevent division by zero
		T2=s2*StepMM;
		st=s2/Math.floor(T2);
		T2=Math.floor(T2)+1;
		for (Ti=0;Ti<T2;Ti++){
		    // main code 
			V=(V2+as*Ti);
			machinemove(2,S,V); // we keep the value quadratic and only square when needed
			S+=st;
			// drawing code
		}
		V=sqrt(V); // for next segment
	}
	S0=s1+s2;
	
	// segment 3 look like segment 1 but have starting acceleration
	
	if (has3){
		t=0;
		// this 0.5 need to adjusted depends on real mm step per machine step
		Vi=V; // just to prevent division by zero
		ss=s1+s2+s3;
		while (t<=t3){
		    // main code
			tc=t3-t;
			jc=0.5*j*tc*tc;			
			V=(vc-jc)+0.05;
			S=ss-vc*tc+0.3334*jc*tc;
			//if (S>s3)break;
			machinemove(3,S,V);
			t+=tstep;//fmax(tmax,cs2/V);
		}
	}
	S0=S0+s3;
	// segment 4 is so simple its constant velocity
	if (has4) {
		T2=s4*StepMM;
		S=0;
		st=s4/T2;
		for (Ti=0;Ti<T2;Ti++){
		    // main code 
			S+=st;
			machinemove(4,S0+S,vc);
		}
	}	
	S0=S0+s4;
	
	// segment 5 look like segment 1 but decelerating
	a5=a;
	if (has5){
		t=0;
		Vi=vc; // just to prevent division by zero
		a5=0;
		while (t<=t5){
		    // main code
			t+=tstep;//fmax(tmax,cs2/V);
			jc=0.5*a5*t;			
			V=Vi-jc;
			S=Vi*t - 0.3334*jc*t;
			a5=j*t;
			//if (S>s5)break;
			machinemove(5,S0+S,V);
		}
	}
	S0=S0+s5;

	/* segment 6 is simple constant acceleration
	
	Vf^2 = Vi^2 - 2aS
	so each step we only need to add 2a
	*/
	if (has6){
		t=0;
		as=2*a5/StepMM;
		V2=sqr(V); // just to prevent division by zero
		T6=s6*StepMM;
		st=s6/Math.floor(T6);
		T6=Math.floor(T6)+1;
		S=S0;
		for (Ti=0;Ti<T6;Ti++){
		    // main code 
			V=(V2-as*Ti);
			S+=st;
			machinemove(6,S,V); // just like seg 2, keep it squared
		}
		V=sqrt(V);
	}
	S0=S0+s6;
	
	// segment 7 look like segment 3 but have starting acceleration
	
	if (has7){
		t=0;
		S=0;
		Vi=V;
		/*
		while (t<=t7){
			t+=tstep;//fmax(tmax,cs2/V);
			jc=(a5-0.5*j*t)*t;			
			V=Vi-jc;
			S=(Vi-jc*0.3334)*t;
			if (S>s7)break;
			machinemove(7,S0+S,V);
		}
		*/
		///*
		while (t<=t7){
			tc=t7-t;
			//if (tc<0)break;
			jc=0.5*j*tc*tc;			
			V=ve+jc;
			S=mmdis-ve*tc-1/6*j*tc*tc*tc;
			machinemove(7,S,V);
			t+=tstep;//fmax(tmax,cs2/V);
		}
		//*/
	}
	S0=S0+s7;
	
	
}
var mdis,workstepl;
function machinemove(sg,dis,vel){
	// for debugging
	// 
	
	var steps=Math.floor(dis*StepMM)-Math.floor(mdis*StepMM);
	if (steps>0){ // sometimes the calculation emit negative delta steps ... prevent it
		//
		
		if (sg==2 || sg==6)vel=sqrt(vel);
		var t=clockrate/(fmax(vel,minVel)); // prevent zero speed
		if (workstep<=totalstep)	
		//stepBuff.push([sg,dis,vel]);

		for (var i=0;i<steps;i++){
			if (workstep<totalstep){
				// do bresenham this step longs
			}
			workstep++;
		}
		// send the t with other things needed to timerbufer
		mdis=dis; // save last step position
	}
}


function prepareramp(bpos)
{
	// local m
    var m = move[bpos];

    faxis = FASTAXIS(m);
    ytotalstep = abs(m.dx[faxis]);

    stepa = 1.0 / (m.ac);
	prevacc=nextacc;
	
    if (bpos!=(head)) {
        next=move[nextbuff(bpos)];
        fe=next.fs;
		if (next.fn<next.fs)nextacc=-1;
		if (next.fn==next.fs)nextacc=0;
		if (next.fn<next.fs)nextacc=+1;		
    } else {
		fe=0;
		nextacc=0;
	}
    m.totalstep=ytotalstep;
    m.status |= 4;
}


function backforward()
{
// now back planner
    h=head;//
    //h=prevbuff(head);
    if (h==tailok) {
        return 0;
    }

    var next;
    curr = move[h];
    curr.fs=min(curr.maxs,(curr.ac*curr.dis));
    h=prevbuff(h);

    while (h!=tailok) {
        next=curr;
        curr=move[h];
        if (curr.fs!=curr.maxs) {
            fs=next.fs+(curr.ac*curr.dis);
            if (fs<curr.maxs) {
                curr.fs=fs;
            } else {
                curr.fs=curr.maxs;
            }
        }
        h=prevbuff(h);
    }

// forward
    //h=nextbuff(tailok);
    //if (h==head) {
     //   return 0;
    //}
    h=tailok;
	
	next=move[h];
    h=nextbuff(h);
    while (h!=head) {
        curr=next;
        next=move[h];
        if (curr.fs<next.fs) {
            fs=curr.fs+(curr.ac*curr.dis);
            if (fs<next.fs) {
                next.fs=fs;
                tailok=prevbuff(h);
            }
            curr.fn=min(fs,curr.fn);
        }
        if (next.fs==next.maxs) tailok=prevbuff(h);
        h=nextbuff(h);
    }

}


function planner(h){
  curr=move[h];
  scale=1;
  xtotalstep=abs(curr.dx[curr.faxis]);
  copy(prevu,curru);
  curru[4] = 1;
  for (var i=0;i<4;i++){
    curru[i]=0;
    if (curr.dx[i]!=0){
      cdx = (curr.fn) * mmdis[i];
      if ((i != 3)) {
        scale2 = (maxf[i]) * curr.dis / fabs(cdx);
        if (scale2 < scale) scale = scale2;
      }
      // if Z then need to scale the acceleration too
      if (i == 2) {
        scalea = zaccel * curr.dis / fabs(curr.ac * mmdis[i]);
        if (scalea < 1)curr.ac *= scalea;
      }
      curru[i] = mmdis[i] / curr.dis;
    }
  }
  var ucorner = xycorner * scale;
  scale *= curr.fn;
  curr.fn = (scale * scale);

  max_f = MINCORNERSPEED * MINCORNERSPEED;
  if (bufflen()>1) {

     var junc_cos = -prevu[0] * curru[0] - prevu[1] * curru[1] - prevu[2] * curru[2];
    if (junc_cos > 0.999999) {
      max_f = MINCORNERSPEED * MINCORNERSPEED;
    } else if (junc_cos < -0.999999) {
      max_f = 40000;
    } else {
      var sin_theta_d2 = sqrt(0.5 * (1.0 - junc_cos)); // Trig half angle identity. Always positive.
      max_f = fmax( 1, (ucorner * sin_theta_d2) / (1.0 - sin_theta_d2) );
    }


  }
  curr.maxs=min(curr.fn,lastf);
  curr.maxs=min(curr.maxs,max_f);
  lastf=curr.fn;
  backforward();
}

var lastx=0;
var lasty=0;

function addmove(fs,x2,y2,z2,e2,g0,rel) {
  
  var curr=move[nextbuff(head)];
  if (rel) {
    x2+=x1;
    y2+=y1;
    z2+=z1;
    e2+=e1;
  }
  copy(lastmm,currmm);
  currmm[0]=mmdis[0] = (x2 - x1);
  currmm[1]=mmdis[1] = (y2 - y1);
  currmm[2]=mmdis[2] = (z2 - z1);
  mmdis[3] = (e2 - e1);

  var dx=[];
  dx[0]=int(x2*stepmm)-int(x1*stepmm);
  dx[1]=int(y2*stepmm)-int(y1*stepmm);
  dx[2]=int(z2*stepmm)-int(z1*stepmm);
  dx[3]=int(e2*stepmm)-int(e1*stepmm);

  curr.dis = sqrt(sqr2(mmdis[0]) + sqr2(mmdis[1]) + sqr2(mmdis[2]));
  curr.dx=dx;
  
  dd=0;
  faxis=0;
  for (var i=0;i<4;i++){
    var d=Math.abs(dx[i]);
	if (d>dd){
      dd=d;
      faxis=i;
    }
  }

  head=nextbuff(head);
  curr.fn=fs;
  curr.fs=0;
  curr.status=g0?8:0;
  curr.x1=x1;
  curr.y1=y1;
  curr.z1=z1;
  curr.faxis=faxis;
  curr.status |= faxis << 4;
  curr.status|=1;
  curr.ac = 2 * (g0 ? mvaccel : accel);
  planner(head);
  x1=x2;
  y1=y2;
  z1=z2;
  e1=e2;


}
function calculate_delta_steps(){
  for (var i = 0; i < 4; i++) {


    if (m.dx[i] > 0) {
      bsdx[i] = (m.dx[i]);
      sx[i] = 1;
    } else {
      bsdx[i] = -(m.dx[i]);
      sx[i] = -1;
    }
  }
  var ff=max(m.fe,max(m.fs,m.fn)); // get fastest speed
  /*var u=xInvSqrt(ff)/STEPCLOCK;
  u=1.1;
  mctr = Math.round(totalstep*u) ;
  totalstep = mctr;
  acup /= u;
  acdn /= u;
  stepdiv2 /= u;
  stepdiv /= u;
  */
  mctr =totalstep; 
  newdircommand(!isG0 ? 255 : 0);
}

function startmove()
{

    if ((head == tail)) {
        return 0;
    }
    t = nextbuff(tail);
    prepareramp(t);
	preparejerk(m.ac/2,jerk,sqrt(fs),sqrt(fn),sqrt(fe));
	// global m
	m=move[t];
	isG0 = m.status & 8;

	laxis = fastaxis;
	fastaxis = FASTAXIS(m);
	totalstep = labs(m.dx[fastaxis]);


	
	stepdiv = CLOCKCONSTANT* m.dis / totalstep;
	stepdiv2 = wstepdiv2 = stepdiv;
	m.status &= ~3;
	m.status |= 2;


	if (f == 0)
		nextmicros = micros();// if from stop

	mctr2 = mcx[0] = mcx[1] = mcx[2] = mcx[3] = 0; //mctr >> 1;
	tail = t;


	//zprintf(PSTR("Last %f %f %f \n"), ff(px[0] / stepmmx[0]), ff(px[1] / stepmmx[0]), ff(px[2] / stepmmx[0]));
	//zprintf(PSTR("sx %d %d %d \n"), fi(sx[0]), fi(sx[1]), fi(sx[2]));
	//zprintf(PSTR("Status:%d \n"), fi(m.status));

	calculate_delta_steps();
	dlp=xInvSqrt(ta);

	
	// laser
	return 1;
}

var GX=[0,0,0,0];
function bresenham(ix){
  if ((mcx[ix] -= bsdx[ix]) < 0) {
    cmd0 |=2<<ix;	
    mcx[ix] += totalstep;
	GX[ix]+=sx[ix];
	
	
  }
}

function coreloop1(){
  if (!m || (mctr <= 0)) {
    return 0;
  }


  if (cmdfull()) {
    //zprintf(PSTR("F\n"));
  } else   {
    cmd0 = 1; //step command

    bresenham(0);
    bresenham(1);
    bresenham(2);
    bresenham(3);
    // next speed
    cmd0 |= Math.round(dlp) << 5;
	vv.push(stepdiv2/dlp);
    pushcmd();

    if (--mctr >0){
		var cf=0;
		if ((rampup -= rampv) > 0) {
		  accele(acup);
		  cf=1;
		} else if ((rampdown -= rampv) < 0) {
		  accele(acdn);
		  // de-advance of the extruder
		  cf=1;
		}
		if (cf){
		  if (ta < 0.1)ta = 0.1;
		  //zprintf(PSTR("%d\n"),fi(ta));
		  // if G0 update delay not every step to make the motor move faster
		  //if (m->status & 8) {
		}
		dlp=xInvSqrt(ta); //*F_SCALE;
		return 1;
	} return 0;
  }
  return 1;
}


// ===================================================================================
// MAIN CODE
// ===================================================================================

var demo="circle";

if (demo=="box"){

	addmove(30,20,10,0,0);
	addmove(13,20,30,0,0);
	addmove(12,0,20,0,0);
	addmove(8,0,0,0,0);
}
if (demo=="line"){
	addmove(30,20,10,0,0);
}
if (demo=="circle"){
  for(var x=0;x<13;x++){
	var d=x/14.0*44/7;
    addmove(15, +Math.sin(d)*30, Math.cos(d)*30, 0, 0);
  }
//addmove(10, 0, 0, 0, 0);
}
ctx.beginPath();
ctx.strokeStyle="white";
ss=4.0/stepmm;
while (startmove()){
	// bresenham motion loop
	while (coreloop1()){
		x=200+GX[0]*ss;
		y=300+GX[1]*ss;
		
		ctx.lineTo(x,y);
		
	};
}
ctx.stroke();

var cmdly,cmcmd;
function decodecmd()
{
  if (cmdempty()) {

    return 0;

  }
  cmtail = nextbuffm(cmtail);
  var cmd = cmddelay[cmtail];
  cmcmd = cmd & 1;
  if (cmcmd) {
    cmbit = (cmd >> 1) & 15;
    cmdly = (cmd >> 5);
  } else {
    cmbit = (cmd >> 1) & 255;
    cmdly = 20;
  }
  return 1;
}

	
ff=0;
var tm=0;
function getf(i){
	var tm=0;
	var tv=0;
	var T=5;
	for (var j=-T;j<T;j++){
		var n=i+j;
		var v=-5;
		if (n>0 && n<vv.length)v=vv[n];
		tv+=v;
		tm++;
	}
	return max(0.2,tv/tm);
}
function getf2(i){
	var tm=0;
	var tv=0;
	var T=5;
	for (var j=-T;j<T;j++){
		var n=i+j;
		var v;
		if (n<0)v=1500000;
		else if (n>=ddd.length)v=1500000;
		else v=ddd[n];		
		tv+=v;
		tm++;
	}
	return tv/tm;
}
var GS=10;
var GY=500;
var GX=400;
ctx.beginPath();

ctx.strokeStyle="gray";
ctx.fillStyle="white";
for (var Y=0;Y<8;Y++){
	ctx.moveTo(GX,GY-Y*5*GS);
	ctx.lineTo(1600,GY-Y*5*GS);
	ctx.fillText(Y*5,GX-30,GY-Y*5*GS);
}
ctx.stroke();
function drawF(intp,c,mask,ZY){
	ctx.beginPath();
	ctx.strokeStyle=c;
	x=GX;
	var ni=0;
	cmtail=0;
	var stepd=CLOCKCONSTANT/stepmm;
	var ldly=0;
	while (decodecmd()){
		if (cmcmd){
			ldly+=cmdly;
			f=8*CLOCKCONSTANT/(cmdly*stepmm);
			if (intp)f=getf(ni++)*GS; else f=vv[ni++]*GS;
			//f=stepd*GS/getf2(ni++);
			tm+=cmdly;
			ctx.lineTo(x, GY-f+ZY);
			x+=cmdly/20000;
		}// else 	ldly+=cmdly;
	}
	ctx.stroke();
}


drawF(0,"green",2,-100);
drawF(1,"red",2,0);

console.log("Total time:%f:",tm/CLOCKCONSTANT);
console.log(ddd);

</script>
</body>
</html>
